from tkinter import Tk, Canvas, Frame, Button, BOTH, TOP, BOTTOM, Label, font, Message
import tkinter as tk
import time
from sudoku_solver import SudokuBoard

MARGIN = 20
SIDE = 50
WIDTH = HEIGHT = MARGIN * 2 + SIDE * 9
delay = 0.1

class SudokuUI(Frame):
    def __init__(self, parent):

        # Load an initial board
        self.sudoku = SudokuBoard()

        # UI Code
        Frame.__init__(self, parent)
        self.parent = parent
        self.disp_row, self.disp_col = -1, -1

        self.board_loaded = False
        self.solving = False
        self.message_log = ""

        self.__generate_interface()

        pass

    def __generate_interface(self):
        # Generate Tkinter window
        # Generate interface elements, including buttons

        self.parent.title("Sudoku Solver")
        self.parent.resizable(width=False, height=False)
        self.grid(row=0, column=0)
        self.canvas = Canvas(self,
                            width=WIDTH,
                            height=HEIGHT)
        self.canvas.grid(row=0, column=0)

        draw_button = Button(self, 
                            text="Load New Puzzle", 
                            command=self.draw_command)

        draw_button.grid(row=1, column=0, sticky="ew")

        solve_button = Button(self,
                            text="Solve Puzzle",
                            command=self.draw_answers_command)
        solve_button.grid(row=2, column=0, sticky="ew")

        self.lbl_message_log = Message(self, fg="black", bg="gray82", bd=3, width=100)
        self.lbl_message_log.grid(row=3, column=0, sticky="ew")

        self.__draw_grid()

    def __get_board(self, level):
        puzzle_board, solution = self.sudoku.gen_puzzle_board(level=level)
        return puzzle_board, solution

    def __draw_grid(self):
        # Draw the initial grid
        # 9 x 9 with blue lines to divide the 3 x 3 squares
        for i in range(10):
            if i % 3 == 0:
                colour = "blue"
                width = 2
            else:
                colour = "gray"
                width = 1

            # Vertical lines
            x0 = MARGIN + i * SIDE
            y0 = MARGIN
            x1 = MARGIN + i * SIDE
            y1 = HEIGHT - MARGIN

            self.canvas.create_line(x0, y0, x1, y1, fill=colour, width=width)

            # Horizontal lines
            x0 = MARGIN
            y1 = MARGIN + i * SIDE
            x1 = WIDTH - MARGIN
            y0 = MARGIN + i * SIDE

            self.canvas.create_line(x0, y0, x1, y1, fill=colour, width=width)

    def __get_num_coords(self, i, j):
        # Get coordinates for text generation
        # Returns middle of cells
        x = MARGIN + j * SIDE + SIDE/2
        y = MARGIN + i * SIDE + SIDE/2

        return (x,y)

    def __draw_numbers(self, difficulty, original=False, answers=False, visual_solve=False):
        if not self.solving:
            # Load numbers into the board
            self.canvas.delete("numbers")
            self.canvas.delete("solution")
            self.delete_v_solve()

            # Loads new board
            self.puzzle_board, self.solution = self.__get_board(difficulty)

            # Print board to GUI
            for i in range(9):
                for j in range(9):
                    answer = self.puzzle_board[i][j]
                    if answer != 0:
                        x, y = self.__get_num_coords(i,j)
                        self.canvas.create_text(
                            x,y, text=answer, tags="numbers", fill="black"
                        )
                        self.update()   #Tkinter.update function to refresh screen
                        time.sleep(delay)
                        self.lbl_message_log['text'] = "Loading..."
        self.lbl_message_log['text'] = "Board Loaded!"
        self.board_loaded = True

    def __draw_solution(self):
        # Generates an instant solution and can feed it in live
        # Not a true backtracking or display of how the program works.
        if self.board_loaded:
            self.solving = True
            for i in range(9):
                for j in range(9):
                    answer = self.solution[i][j]
                    if self.puzzle_board[i][j] == 0:
                        x, y = self.__get_num_coords(i,j)
                        self.canvas.create_text(
                            x,y, text=answer, tags="solution", fill="sea green"
                        )
                        self.update()
                        time.sleep(delay)

        self.solving = False
    
    def delete_v_solve(self):
        # Delete numbers generated by the solver at __draw_solver
        for row in range(0, 9):
            for col in range(0, 9):
                self.canvas.delete(f"v_solve{row}{col}")

    def __draw_solver(self, board):
        # TODO: Code to generate the iteration and solving.
        #       Will need to generate another internal function to do the backtracking.
        # 1. Loop through board cells, find zeroes and attempt to assign values between 1-9
        # 2. Check the row of the zero for other values that are equal to the assigning value
        # 3. Check the column of the zero for other values that are equal to the assigning value
        # 4. Check the 3x3 square of the zero for other values etc...
        # 5. Assign the value
        # 6. Draw the value
        # 7. Move to next zero.
        if self.board_loaded == True:
            empty_squares = self.sudoku.find_empty(board)
            if not empty_squares:
                self.lbl_message_log['text'] = "Solved!"
                return True
            else:
                row, col = empty_squares
            
            for i in range(1, 10):
                if self.sudoku.check_valid(board, i, (row, col)):
                    board[row][col] = i
                    x,y = self.__get_num_coords(row, col)

                    # Create Tag each generated solution
                    # Bold the solutions
                    text_font = font.Font(size=11, weight="bold") 
                    self.canvas.create_text(
                            x,y, text=i,font=text_font, tags=f"v_solve{row}{col}", fill="dark green", 
                    )
                    self.lbl_message_log['text'] = "Solving..."

                    self.update()
                    time.sleep(0.1)
                    if self.__draw_solver(board): # Recursive function, ie the function calls itself
                        back_count = 0
                        return True

            
                    board[row][col] = 0
                    self.canvas.delete(f"v_solve{row}{col}") # Delete if backtracking
                    x,y = self.__get_num_coords(row, col)

                    self.lbl_message_log['text'] = "Backtracking..."

                    self.update()
                    time.sleep(0.2)

    def draw_command(self):
        # Call the draw_numbers function for the button
        self.__draw_numbers(difficulty="hard", original=True)
    
    def draw_answers_command(self):
        # Call the draw_numbers function for answer button
        self.__draw_solver(self.puzzle_board)

    def __clear_all(self):
        pass

    def __user_inputs(self):
        pass

root = Tk()
SudokuGame = SudokuUI(root)
root.geometry(f"{WIDTH}x{HEIGHT+120}")
root.mainloop()
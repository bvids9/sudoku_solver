from tkinter import Tk, Canvas, Frame, Button, BOTH, TOP, BOTTOM, Label, font, Message
import tkinter as tk
import time
from sudoku_solver import SudokuBoard

MARGIN = 20 # Margin padding the Grid
SIDE = 50   # Cell side length 
WIDTH = HEIGHT = MARGIN * 2 + SIDE * 9  # Size of Grid
delay = 0.1 # Time delay in seconds

class SudokuUI(Frame):
    def __init__(self, parent):

        # Load an initial board
        self.sudoku = SudokuBoard()

        # UI Code
        Frame.__init__(self, parent)
        self.parent = parent
        self.disp_row, self.disp_col = -1, -1

        self.board_loaded = False
        self.solving = False
        self.message_log = ""

        self.__generate_interface()

        pass

    def __generate_interface(self):
        # Generate Tkinter window
        # Generate interface elements, including buttons

        self.parent.title("Sudoku Solver")
        self.parent.resizable(width=False, height=False)
        self.grid(row=0, column=0)
        self.canvas = Canvas(self,
                            width=WIDTH,
                            height=HEIGHT)
        self.canvas.grid(row=0, column=0)

        draw_button = Button(self, 
                            text="Load New Puzzle", 
                            command=self.draw_command)

        draw_button.grid(row=1, column=0, sticky="ew")

        solve_button = Button(self,
                            text="Solve Puzzle",
                            command=self.draw_answers_command)
        solve_button.grid(row=2, column=0, sticky="ew")

        self.lbl_message_log = Message(self, fg="black", bg="gray82", bd=3, width=400)
        self.lbl_message_log.grid(row=3, column=0, sticky="ew")

        self.__draw_grid()

    def __get_board(self, level):
        puzzle_board, solution = self.sudoku.gen_puzzle_board(level=level)
        return puzzle_board, solution

    def __draw_grid(self):
        # Draw the initial grid
        # 9 x 9 with blue lines to divide the 3 x 3 squares
        for i in range(10):
            if i % 3 == 0:
                colour = "blue"
                width = 2
            else:
                colour = "gray"
                width = 1

            # Vertical lines
            x0 = MARGIN + i * SIDE
            y0 = MARGIN
            x1 = MARGIN + i * SIDE
            y1 = HEIGHT - MARGIN

            self.canvas.create_line(x0, y0, x1, y1, fill=colour, width=width)

            # Horizontal lines
            x0 = MARGIN
            y1 = MARGIN + i * SIDE
            x1 = WIDTH - MARGIN
            y0 = MARGIN + i * SIDE

            self.canvas.create_line(x0, y0, x1, y1, fill=colour, width=width)

    def __get_num_coords(self, i, j):
        # Get coordinates for text generation
        # Returns middle of cells
        x = MARGIN + j * SIDE + SIDE/2
        y = MARGIN + i * SIDE + SIDE/2

        return (x,y)

    def __init_draw_numbers(self, difficulty, original=False, answers=False, visual_solve=False):
        if not self.solving:
            # Load numbers into the board
            self.canvas.delete("numbers")
            self.canvas.delete("solution")
            self.delete_v_solve()

            # Loads new board
            self.puzzle_board, self.solution = self.__get_board(difficulty)

            # Print board to GUI
            for i in range(9):
                for j in range(9):
                    answer = self.puzzle_board[i][j]
                    if answer != 0:
                        x, y = self.__get_num_coords(i,j)
                        self.canvas.create_text(
                            x,y, text=answer, tags="numbers", fill="black"
                        )
                        self.update()   #Tkinter.update function to refresh screen
                        time.sleep(delay)
                        self.lbl_message_log['text'] = "Loading..."
        self.lbl_message_log['text'] = "Board Loaded!"
        self.board_loaded = True

    def __draw_solution(self):
        # Generates an instant solution and can feed it in live
        # Not a true backtracking or display of how the program works.
        if self.board_loaded:
            self.solving = True
            for i in range(9):
                for j in range(9):
                    answer = self.solution[i][j]
                    if self.puzzle_board[i][j] == 0:
                        x, y = self.__get_num_coords(i,j)
                        self.canvas.create_text(
                            x,y, text=answer, tags="solution", fill="sea green"
                        )
                        self.update()
                        time.sleep(delay)

        self.solving = False
    
    def delete_v_solve(self):
        # Delete numbers generated by the solver at __draw_solver
        for row in range(0, 9):
            for col in range(0, 9):
                self.canvas.delete(f"v_solve{row}{col}", f"selection{row}{col}")

    def __draw_solver(self, board):

        # Visualisation of the backtracking algorithm
        # A repeat of the sudoku_solver.py function, but broken down to allow visualising

        if self.board_loaded == True:
            empty_squares = self.sudoku.find_empty(board)
            if not empty_squares:
                self.lbl_message_log['text'] = "Solved!"
                return True
            else:
                row, col = empty_squares
            
            for i in range(1, 10):
                # Select the square and display the cycling of solutions
                # Then delete immediately after, if a valid guess is found, the solution code block will enter it.
                x,y = self.__get_num_coords(row, col)

                self.draw_solver_number(i, x,y, row, col, "black")
                self.draw_selection(row, col)
                self.lbl_message_log['text'] = "Guessing..."
                self.update()
                time.sleep(0.05)

                self.canvas.delete(f"v_solve{row}{col}", f"selection{row}{col}")
                
                if self.sudoku.check_valid(board, i, (row, col)):
                    # Get square coordinates and draw the selection to indicate solving
                    x,y = self.__get_num_coords(row, col)
                    self.draw_selection(row, col)
                    self.update()

                    # When solution found, refresh number and selection to green
                    board[row][col] = i
                    self.draw_confirmation(row, col)

                    # Create Tag each generated solution
                    self.draw_solver_number(i, x, y, row, col, "sea green")
                    self.lbl_message_log['text'] = "Solving..."

                    self.update()
                    time.sleep(delay*2)
                    if self.__draw_solver(board): # Recursive function, ie the function calls itself
                        return True

            
                    board[row][col] = 0
                    self.canvas.delete(f"v_solve{row}{col}", f"selection{row}{col}") # Delete if backtracking
                    self.lbl_message_log['text'] = "Backtracking..."

                    self.update()
                    time.sleep(delay*2)

    def draw_command(self):
        # Call the draw_numbers function for the button
        self.__init_draw_numbers(difficulty="hard", original=True)
    
    def get_selection_coords(self, row, col):
        
        x0 = MARGIN + col*SIDE
        y0 = MARGIN + row*SIDE
        
        x1 = x0 + SIDE
        y1 = y0 + SIDE

        return x0, y0, x1, y1

    def draw_selection(self, row, col):
        # Draw red rectangle at currently analysed square
        x0, y0, x1, y1 =  self.get_selection_coords(row, col)
        self.canvas.create_rectangle(x0, y0, x1, y1, outline="red", tags=f"selection{row}{col}")
    
    def draw_confirmation(self, row, col):
        # When moving on from the selected square (ie found a correct number), turn rectangle green
        for rectangle in self.canvas.find_withtag(f"selection{row}{col}"): self.canvas.itemconfig(rectangle, outline="green", width=2)
        time.sleep(delay)
    
    def draw_solver_number(self, number, x, y, row, col, colour):
        # Draw numbers during the solver visualisation
        text_font = font.Font(size=11, weight="bold") 
        self.canvas.create_text(
        x,y, text=number,font=text_font, tags=f"v_solve{row}{col}", fill=colour, 
        )
    
    def draw_answers_command(self):
        # Call the draw_numbers function for answer button
        self.__draw_solver(self.puzzle_board)

    def __user_inputs(self):
        pass

root = Tk()
SudokuGame = SudokuUI(root)
root.geometry(f"{WIDTH}x{HEIGHT+120}")
root.mainloop()